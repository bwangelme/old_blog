<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Review 《File Descriptor Transfer over Unix Domain Sockets》 - 大白的碎碎念</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="bwangel" /><meta name="description" content=" 使用 Unix 域套接字传输文件描述符 原文地址: https://copyconstruct.medium.com/file-descriptor-transfer-over-unix-domain-sockets-dcbbf5b3b6ec " /><meta name="keywords" content="Hugo, blog, bwangel" />






<meta name="generator" content="Hugo 0.101.0 with theme even" />


<link rel="canonical" href="/2021/11/30/file-descriptor-transfer-over-unix-domain-sockets/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.2e81bbed97b8b282c1aeb57488cc71c8d8c8ec559f3931531bd396bf31e0d4dd.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:title" content="Review 《File Descriptor Transfer over Unix Domain Sockets》" />
<meta property="og:description" content="

使用 Unix 域套接字传输文件描述符
原文地址: https://copyconstruct.medium.com/file-descriptor-transfer-over-unix-domain-sockets-dcbbf5b3b6ec

" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/2021/11/30/file-descriptor-transfer-over-unix-domain-sockets/" /><meta property="article:section" content="translate" />
<meta property="article:published_time" content="2021-11-30T11:58:56+08:00" />
<meta property="article:modified_time" content="2021-11-30T11:58:56+08:00" />

<meta itemprop="name" content="Review 《File Descriptor Transfer over Unix Domain Sockets》">
<meta itemprop="description" content="

使用 Unix 域套接字传输文件描述符
原文地址: https://copyconstruct.medium.com/file-descriptor-transfer-over-unix-domain-sockets-dcbbf5b3b6ec

"><meta itemprop="datePublished" content="2021-11-30T11:58:56+08:00" />
<meta itemprop="dateModified" content="2021-11-30T11:58:56+08:00" />
<meta itemprop="wordCount" content="4811">
<meta itemprop="keywords" content="翻译,linux," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Review 《File Descriptor Transfer over Unix Domain Sockets》"/>
<meta name="twitter:description" content="

使用 Unix 域套接字传输文件描述符
原文地址: https://copyconstruct.medium.com/file-descriptor-transfer-over-unix-domain-sockets-dcbbf5b3b6ec

"/>
<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?f22fe9c7aece3dedec2af9976b092478";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>


<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Keep Foolish</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/tips/">
        <li class="mobile-menu-item">Tips</li>
      </a><a href="/leetcode/">
        <li class="mobile-menu-item">LeetCode</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/translate/">
        <li class="mobile-menu-item">翻译</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Keep Foolish</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tips/">Tips</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/leetcode/">LeetCode</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/translate/">翻译</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">关于</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Review 《File Descriptor Transfer over Unix Domain Sockets》</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-11-30 </span>
        
          <span class="more-meta"> 约 4811 字 </span>
          <span class="more-meta"> 预计阅读 10 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#unix-域套接字">Unix 域套接字</a>
          <ul>
            <li><a href="#一个简短的教程">一个简短的教程</a></li>
            <li><a href="#socket-文件--普通文件">Socket 文件 != 普通文件</a></li>
            <li><a href="#使用-bind2-绑定一个已经存在的路径将会失败">使用 bind(2) 绑定一个已经存在的路径将会失败</a></li>
          </ul>
        </li>
        <li><a href="#socketpair">SOCKETPAIR</a></li>
        <li><a href="#在-unux-域套接字上传输数据">在 Unux 域套接字上传输数据</a>
          <ul>
            <li><a href="#file-descriptors文件描述符-vs-file-description-文件描述">File Descriptors(文件描述符) VS File Description (文件描述)</a></li>
            <li><a href="#sendmsg-和-recvmsg">sendmsg 和 recvmsg</a></li>
          </ul>
        </li>
        <li><a href="#辅助数据传输">辅助数据传输</a>
          <ul>
            <li><a href="#scm_rights">SCM_RIGHTS</a></li>
          </ul>
        </li>
        <li><a href="#scm_rights-的陷阱">SCM_RIGHTS 的陷阱</a></li>
        <li><a href="#什么时候发送文件描述符是有用的">什么时候发送文件描述符是有用的</a></li>
        <li><a href="#总结">总结</a></li>
        <li><a href="#references">References:</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <blockquote>
<ul>
<li><strong>使用 Unix 域套接字传输文件描述符</strong></li>
<li>原文地址: <a href="https://copyconstruct.medium.com/file-descriptor-transfer-over-unix-domain-sockets-dcbbf5b3b6ec">https://copyconstruct.medium.com/file-descriptor-transfer-over-unix-domain-sockets-dcbbf5b3b6ec</a></li>
</ul>
</blockquote>
<hr>
<blockquote>
<p><strong>12/31/2020 更新</strong></p>
<p>如果你使用的是较新的内核（Linux 5.6以上），随着一个新的系统调用 <code>pidfd_getfd</code> 的引入，这种复杂性大部分已经被消除了。更多细节请参考 2020年 12-31 发表的文章<a href="https://copyconstruct.medium.com/seamless-file-descriptor-transfer-between-processes-with-pidfd-and-pidfd-getfd-816afcd19ed4">《用 pidfd 和 pidfd_getfd 在进程间无缝传输文件描述符》</a>。</p>
</blockquote>
<p>昨天，我读了一篇惊人的论文，介绍了使用不同协议而且服务许多不同类型请求（长寿的TCP/UDP会话，涉及大块数据的请求等）的服务在Facebook是如何免中断发布的。</p>
<p>Facebook 使用的一种它们叫做 <code>Socket Takeover</code> 的技术。</p>
<p><code>Socket Takeover</code> 实现了 Proxygen 的零停机重启，它以并行方式启动了一个更新的实例，接管了监听的套接字，当旧的实例进入了优雅关闭阶段。新实例负责为新连接提供服务，并响应来自 L4LB Katran 的健康检查探针。老的连接由老的实例提供服务，直到完全关闭，之后其他机制（例如下游连接重用）开始发挥作用。</p>
<p>当我们把一个打开的FD从旧的进程传递给新的进程时，传递和接收的进程都共享监听套接字的同一个文件表项，并各自独立地处理接收的连接，在这些连接上提供连接级事务。我们利用了以下Linux内核的特性来实现这一点。</p>
<p><strong>CMSG</strong>：<code>sendmsg()</code> 的一个功能允许在本地进程之间发送控制信息（通常被称为辅助数据）。在 Level7 LB 进程的重启过程中，我们使用这一机制将所有 VIP ( Virtual IP of service) 的活动的监听套接字的 FD 集合从活动的实例发送至新启动的实例。这些数据是通过 <code>sendmsg</code> 和 <code>recvmsg</code> 在 UNIX 域套接字上交换的。</p>
<p><strong>SCM_RIGHTS</strong>: 我们设置这个选项来发送打开的文件描述符，其数据部分包含一个打开的FD的整数数组。在接收方，这些 文件描述符的行为就像它们是用 <code>dup(2)</code> 创建的一样。</p>
<p>我在 Twitter 上收到了一些人的回复，他们对这竟然是可能的表示惊讶。事实上，如果你对Unix域套接字的一些特性不是很熟悉，那么论文中的上述段落可能就很难理解了。</p>
<p>实际上，在 Unix 域套接字上传输 TCP 套接字是一种久经考验的方法，来实现 <strong>热重启</strong> 或 <strong>零停机时间重启</strong> 。流行的代理，如 HAProxy 和 Envoy ，使用非常类似的机制，将连接从代理的一个实例引流到另一个实例，而不丢弃任何连接。然而，许多类似的功能却并不广为人知。</p>
<p>在这篇文章中，我想探讨 Unix 域套接字的一些特性，这些特性使它成为这些场景下的合适候选者，特别是将套接字（或任何文件描述符）从一个进程转移到另一个进程，在这两个进程之间不一定存在父子关系。</p>
<h2 id="unix-域套接字">Unix 域套接字</h2>
<p>众所周知，Unix 域套接字允许同一主机系统上的进程之间进行通信。Unix域套接字在许多流行的系统中都有使用。HAProxy、Envoy、AWS的 Firecracker 虚拟机监视器、Kubernetes、Docker和 Istio 等等。</p>
<h3 id="一个简短的教程">一个简短的教程</h3>
<p>就像网络套接字一样，Unix 域套接字也支持流和数据报文类型。然而，与采用 IP 和端口作为地址的网络套接字不同，Unix域套接字使用路径名作为地址。与网络套接字不同，Unix域套接字的 I/O 不涉及对底层设备的操作（这使得Unix域套接字与网络套接字相比，在同一主机上执行IPC要快很多）。</p>
<p>用 <code>bind(2)</code> 将一个名字绑定到一个Unix域套接字，在文件系统中创建一个名为 <code>pathname</code> 的套接字文件。然而，这个文件与你可能创建的任何普通文件不同。</p>
<p>一个简单的Go程序在 Unix 域套接字上创建一个监听的 &ldquo;Echo 服务器&rdquo;，如下所示:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;io&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;log&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;net&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;syscall&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">const</span> <span class="nx">addr</span> <span class="p">=</span> <span class="s">&#34;/tmp/uds.sock&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">syscall</span><span class="p">.</span><span class="nf">Unlink</span><span class="p">(</span><span class="nx">addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">l</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">net</span><span class="p">.</span><span class="nf">Listen</span><span class="p">(</span><span class="s">&#34;unix&#34;</span><span class="p">,</span> <span class="nx">addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">l</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">l</span><span class="p">.</span><span class="nf">Accept</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="nx">net</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">io</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}(</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果你建立并运行这个程序，可以观察到几个有趣的事实。</p>
<h3 id="socket-文件--普通文件">Socket 文件 != 普通文件</h3>
<p>首先，套接字文件 <code>/tmp/uds.sock</code> 被标记为一个套接字。当使用 <code>stat()</code> 调用查看这个路径名时，它在stat结构的<code>st_mode</code>字段的文件类型部分返回值 <code>S_IFSOCK</code> 。</p>
<p>当用<code>ls -l</code>查看时，UNIX 域套接字在第一列显示为s类型，而 <code>ls -F</code> 在套接字路径名上附加一个等号（=）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">root@1fd53621847b:~/uds# ./uds
</span></span><span class="line"><span class="cl">^C
</span></span><span class="line"><span class="cl">root@1fd53621847b:~/uds# ls -ls /tmp
</span></span><span class="line"><span class="cl">total 0
</span></span><span class="line"><span class="cl">0 srwxr-xr-x 1 root root 0 Aug  5 01:45 uds.sock
</span></span><span class="line"><span class="cl">root@1fd53621847b:~/uds# stat /tmp/uds.sock
</span></span><span class="line"><span class="cl">File: /tmp/uds.sock
</span></span><span class="line"><span class="cl">Size: 0          Blocks: 0          IO Block: 4096   socket
</span></span><span class="line"><span class="cl">Device: 71h/113d Inode: 1835567     Links: 1
</span></span><span class="line"><span class="cl">Access: (0755/srwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)
</span></span><span class="line"><span class="cl">Access: 2020-08-05 01:45:41.650709000 +0000
</span></span><span class="line"><span class="cl">Modify: 2020-08-05 01:45:41.650709000 +0000
</span></span><span class="line"><span class="cl">Change: 2020-08-05 01:45:41.650709000 +0000
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Birth: -
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">root@5247072fc542:~/uds# ls -F /tmp
</span></span><span class="line"><span class="cl">uds.sock=
</span></span><span class="line"><span class="cl">root@5247072fc542:~/uds#
</span></span></code></pre></td></tr></table>
</div>
</div><p>对文件起作用的普通系统调用在套接字文件上不起作用：这意味着像 <code>open()</code> 、<code>close()</code> 、<code>read()</code> 这样的系统调用不能用于套接字文件。相反，像 <code>socket()</code> 、<code>bind()</code> 、<code>recv()</code> 、<code>sendmsg()</code> 、<code>recvmsg()</code> 等套接字相关的系统调用可以在 Unix域套接字上工作。</p>
<p>另一个关于套接字的有趣事实是，它不是在套接字被关闭的时候删除，而是通过系统调用来删除</p>
<ul>
<li>在 MacOS 上调用 <code>unlink(2)</code></li>
<li>在 Linux 上调用 <code>remove()</code> 或使用地更普遍的 <code>unlink(2)</code></li>
</ul>
<p>在 Linux 上，Unix 域套接字的地址通过如下的结构来表示:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">struct sockaddr_un {
</span></span><span class="line"><span class="cl">      sa_family_t sun_family; /* Always AF_UNIX */
</span></span><span class="line"><span class="cl">      char sun_path[108]; /* Pathname */
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 MacOS 上，地址通过如下的结构表示:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">struct sockaddr_un {
</span></span><span class="line"><span class="cl">     u_char  sun_len;
</span></span><span class="line"><span class="cl">     u_char  sun_family;
</span></span><span class="line"><span class="cl">     char    sun_path[104];
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="使用-bind2-绑定一个已经存在的路径将会失败">使用 bind(2) 绑定一个已经存在的路径将会失败</h3>
<p><code>SO_REUSEPORT</code> 选项允许任何指定主机上的多个网络套接字连接到同一地址和端口。第一个试图绑定给定端口的套接字需要设置 <code>SO_REUSEPORT</code> 选项，任何后续的套接字都可以绑定到同一端口。</p>
<p>对 <code>SO_REUSEPORT</code> 的支持是在 Linux 3.9及以上版本中引入的。然而，在 Linux 上，所有想共享同一地址和端口组合的套接字必须属于共享同一有效UID的进程。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">socktype</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">optval</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">setsockopt</span><span class="p">(</span><span class="n">sfd</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_REUSEPORT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">optval</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">optval</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="n">bind</span><span class="p">(</span><span class="n">sfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="n">addrlen</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然而，两个 Unix 域套接字无法绑定相同的路径。</p>
<h2 id="socketpair">SOCKETPAIR</h2>
<p><code>socketpair()</code> 函数创建了两个套接字，然后将其连接在一起。从某种程度上说，这与 <strong>管道</strong> 非常相似，只是它支持数据的双向传输。</p>
<p><code>socketpair</code> 只对 Unix 域套接字起作用。它返回两个已经连接在一起的文件描述符（所以我们不必在开始传输数据之前
, 执行 <code>socket</code> -&gt; <code>bind</code> -&gt; <code>listen</code> -&gt; <code>accept</code>的流程来建立一个监听套接字。也不必在开始传输数据之前，执行 <code>socket</code> -&gt; <code>connect</code> 的流程创建一个连接到监听套接字的客户端）。</p>
<h2 id="在-unux-域套接字上传输数据">在 Unux 域套接字上传输数据</h2>
<p>现在我们已经确定 Unix 域套接字允许同一主机上的两个进程进行通信，现在是时候探索什么样的数据可以通过 Unix 域套接字传输。</p>
<p>由于Unix域套接字在许多方面与网络套接字相似，任何通常可以通过网络套接字发送的数据都可以通过Unix域套接字发送。</p>
<p>此外，特殊的系统调用 <code>sendmsg</code> 和 <code>recvmsg</code> 允许在Unix域套接字上发送一个特殊的消息。这个消息由内核特别处理，它允许从发送者向接收者传递打开的 <strong>File Descriptions</strong>。</p>
<h3 id="file-descriptors文件描述符-vs-file-description-文件描述">File Descriptors(文件描述符) VS File Description (文件描述)</h3>
<p>注意上一段我使用了术语 文件描述(<code>File descripTION</code>)，而不是文件描述符 (<strong>file descripTOR</strong>)。它们两者的区别是微妙的而且往往不被人理解。</p>
<p>文件描述符实际上只是一个进程内(不可跨进程使用)指向底层内核数据结构的指针，该结构被称为文件描述（<strong>File Description</strong>）。内核维护着一个所有打开的文件描述的表格，称为打开文件表(<strong>open file table</strong>)。如果两个进程（A和B）试图打开同一个文件，这两个进程可能有自己独立的文件描述符，它们指向开放文件表中的同一个文件描述。</p>
<p><img src="https://passage-1253400711.cos.ap-beijing.myqcloud.com//2021-11-30-142542.png" alt="img"></p>
<p>所以，在 Unix 域套接字上使用 <code>sendmsg</code> 发送文件描述符实际上意味着发送 <strong>文件描述</strong> 的引用。如果进程 A 向 进程 B 发送文件描述符 0 (fd0)，该文件描述符在进程 B 中很可能被数字3(fd3) 所引用。</p>
<p>发送进程在 Unix 域套接字上调用 <code>sendmsg</code> 发送文件描述符，接收进程在 Unix 域套接字上调用 <code>recvmsg</code> 来接受文件描述符。</p>
<p>发送进程通过 <code>sendmsg</code> 发送文件描述给接收进程，接收进程通过 <code>recvmsg</code> 接收该文件描述。即使发送进程在发送完成后关闭了该文件描述所对应的文件描述符，而接收进程还未调用 <code>recvmsg</code> 接收它，该文件描述依然对接收进程保持打开状态。</p>
<p><strong>发送文件描述符时，文件描述的引用次数会+1,直到文件描述的引用次数下降到0, 内核才会将文件描述从 <code>打开文件表(open file table)</code> 中删除该文件描述。</strong></p>
<p>即使发送进程在接收进程调用 recvmsg 之前关闭了引用通过 sendmsg 传递的文件描述的文件描述符，该文件描述符仍然对接收进程开放。发送描述符时，描述符的引用次数会增加1。内核只有在引用计数下降到0时才会从其开放文件表中删除文件描述。</p>
<h3 id="sendmsg-和-recvmsg">sendmsg 和 recvmsg</h3>
<p>在 Linux 中 <code>sendmsg</code> 函数的签名如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">ssize_t</span> <span class="nf">sendmsg</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">socket</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">message</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">flags</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>与 <code>sendmsg</code> 对应的是 <code>recvmsg</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">ssize_t</span> <span class="nf">recvmsg</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">     <span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">     <span class="k">const</span> <span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msg</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">     <span class="kt">int</span> <span class="n">flags</span>
</span></span><span class="line"><span class="cl"><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>人们可以用 <code>sendmsg</code> 在 Unix 域套接字上传输的特殊消息是由 <code>msghdr</code> 指定的。希望将文件描述发送给另一个进程的进程创建一个 <code>msghdr</code> 结构，其中包含要传递的描述。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">msghdr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span>            <span class="o">*</span><span class="n">msg_name</span><span class="p">;</span>      <span class="cm">/* optional address */</span>
</span></span><span class="line"><span class="cl">    <span class="n">socklen_t</span>       <span class="n">msg_namelen</span><span class="p">;</span>    <span class="cm">/* size of address */</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span>          <span class="n">iovec</span> <span class="o">*</span><span class="n">msg_iov</span><span class="p">;</span> <span class="cm">/* scatter/gather array */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span>             <span class="n">msg_iovlen</span><span class="p">;</span>     <span class="cm">/* # elements in msg_iov */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span>            <span class="o">*</span><span class="n">msg_control</span><span class="p">;</span>   <span class="cm">/* ancillary data, see below */</span>
</span></span><span class="line"><span class="cl">    <span class="n">socklen_t</span>       <span class="n">msg_controllen</span><span class="p">;</span> <span class="cm">/* ancillary data buffer len */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span>             <span class="n">msg_flags</span><span class="p">;</span>      <span class="cm">/* flags on received message */</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>msghdr</code> 结构的 <code>msg_control</code> 成员，其长度为 <code>msg_controllen</code> ，指向一个如下形式的消息缓冲区:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">cmsghdr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">socklen_t</span> <span class="n">cmsg_len</span><span class="p">;</span>    <span class="cm">/* data byte count, including header */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span>       <span class="n">cmsg_level</span><span class="p">;</span>  <span class="cm">/* originating protocol */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span>       <span class="n">cmsg_type</span><span class="p">;</span>   <span class="cm">/* protocol-specific type */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* followed by */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">cmsg_data</span><span class="p">[];</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 POSIX 中，带有附加数据的 <code>cmsghdr</code> 结构的缓冲区被称为辅助数据(ancillary data)。在 Linux 上，每个套接字允许的最大缓冲区大小可以通过修改 <code>/proc/sys/net/core/optmem_max</code> 来设置。</p>
<h2 id="辅助数据传输">辅助数据传输</h2>
<p>虽然这种数据传输有大量的陷阱，但如果使用得当，它可以成为一个相当强大的机制来实现一些目标。</p>
<p>在Linux上，有三种类型的辅助数据可以在两个Unix域套接字之间共享。</p>
<ul>
<li><code>SCM_RIGHTS</code></li>
<li><code>SCM_CREDENTIALS</code></li>
<li><code>SCM_SECURITY</code></li>
</ul>
<p>这三种类型的辅助数组仅应该通过下面的宏定义来访问，而不应该直接使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">cmsghdr</span> <span class="o">*</span><span class="nf">CMSG_FIRSTHDR</span><span class="p">(</span><span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msgh</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">cmsghdr</span> <span class="o">*</span><span class="nf">CMSG_NXTHDR</span><span class="p">(</span><span class="k">struct</span> <span class="n">msghdr</span> <span class="o">*</span><span class="n">msgh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cmsghdr</span> <span class="o">*</span><span class="n">cmsg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">size_t</span> <span class="nf">CMSG_ALIGN</span><span class="p">(</span><span class="n">size_t</span> <span class="n">length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">size_t</span> <span class="nf">CMSG_SPACE</span><span class="p">(</span><span class="n">size_t</span> <span class="n">length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">size_t</span> <span class="nf">CMSG_LEN</span><span class="p">(</span><span class="n">size_t</span> <span class="n">length</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">CMSG_DATA</span><span class="p">(</span><span class="k">struct</span> <span class="n">cmsghdr</span> <span class="o">*</span><span class="n">cmsg</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我从来没有使用后两者的需要，<code>SCM_RIGHTS</code> 是我希望在这篇文章中进一步探讨的。</p>
<h3 id="scm_rights">SCM_RIGHTS</h3>
<p><code>SCM_RIGHTS</code> 允许进程使用 <code>sendmsg/recvmsg</code> 从另一个进程发送/接收一组打开的文件描述符。</p>
<p><code>cmsghdr</code> 结构体的成员 <code>cmsg_data</code> 可以包含一个进程想要发送的文件描述符的数组。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">struct cmsghdr {
</span></span><span class="line"><span class="cl">    socklen_t cmsg_len;    /* data byte count, including header */
</span></span><span class="line"><span class="cl">    int       cmsg_level;  /* originating protocol */
</span></span><span class="line"><span class="cl">    int       cmsg_type;   /* protocol-specific type */
</span></span><span class="line"><span class="cl">    /* followed by */
</span></span><span class="line"><span class="cl">    unsigned char cmsg_data[];
</span></span><span class="line"><span class="cl">};
</span></span></code></pre></td></tr></table>
</div>
</div><p>接收进程使用 <code>recvmsg</code> 接收数据。</p>
<p>《Linux Programming Interface》有一个使用 <code>sendmsg</code> 和 <code>recvmsg</code> 函数的<a href="https://man7.org/tlpi/code/online/dist/sockets/scm_rights_send.c.html">良好示例</a>。</p>
<h2 id="scm_rights-的陷阱">SCM_RIGHTS 的陷阱</h2>
<p>正如上文所讲，使用 Unix 域套接字传输辅助数据有很多的陷阱。</p>
<blockquote>
<p><strong>Need to send some “real” data along with the ancillary message</strong></p>
<p>需要在发送辅助数据的同时发送一些真实的数据</p>
</blockquote>
<p>在 Linux 上，如果想要成功地在 <strong>流式(stream)</strong> Unix 域套接字上发送辅助数据，至少要发送一个字节的真实数据。</p>
<p>然而，如果想要在 <strong>数据报式(datagram)</strong> 的 Unix 域套接字上发送辅助数据，不需要发送任何附带的真实数据。也就是说，在通过数据报套接字发送辅助数据时，便携式应用程序还应该包括至少一个字节的真实数据。</p>
<blockquote>
<p>File Descriptors can be dropped</p>
<p>文件描述符可以被丢弃</p>
</blockquote>
<p>如果用于接收包含文件描述符的辅助数据的缓冲区 <code>cmsg_data</code> 太小（或没有），那么辅助数据被截断（或丢弃），多余的文件描述符在接收进程中被自动关闭。</p>
<p>如果在辅助数据中收到的文件描述符的数量导致进程超过其 <code>RLIMIT_NOFILE</code> 资源限制，则多余的文件描述符将在接收进程中自动关闭。不能在多个 <code>recvmsg</code> 调用中分割列表。</p>
<blockquote>
<p>recvmsg quirks</p>
<p>recvmsg 的怪异情况</p>
</blockquote>
<p><code>sendmsg</code> 和 <code>recvmsg</code> 的作用类似于 <code>send</code> 和 <code>recv</code> 系统调用，在每个 <code>send</code> 调用和每个 <code>recv</code> 调用之间没有1：1的映射。</p>
<p>一个 <code>recvmsg</code> 调用可以从多个 <code>sendmsg</code> 调用中读取数据。同样地，它可能需要多个<code>recvmsg</code>调用来消耗一个<code>sendmsg</code> 调用所发送的数据。这有严重的、令人惊讶的影响，其中一些已经在这里报告。</p>
<blockquote>
<p>Limit on the number of File Descriptions</p>
<p>文件描述符的数量限制</p>
</blockquote>
<p>内核常量 <code>SCM_MAX_FD</code> ( 253 (或者在2.6.38之前的内核中为255))定义了数组中文件描述符的数量限制。</p>
<p>试图发送一个大于这个限制的数组会导致 <code>sendmsg</code> 失败，错误是 <code>EINVAL</code>。</p>
<h2 id="什么时候发送文件描述符是有用的">什么时候发送文件描述符是有用的</h2>
<p>一个非常具体的现实世界的使用案例是零停机时间的代理重载。</p>
<p>任何曾经使用过HAProxy的人都可以证明，&ldquo;零停机时间的配置重载 &ldquo;在很长一段时间内并不是一个真正的东西。通常，大量的<a href="https://engineeringblog.yelp.com/2015/04/true-zero-downtime-haproxy-reloads.html">Rube Goldberg-esque</a> Hack 被用来实现这一目标。</p>
<p>在2017年底，HAProxy 1.8 支持无中断重载，通过将监听套接字文件描述符从旧的 HAProxy 进程转移到新的进程中来实现。Envoy使用 <a href="https://blog.envoyproxy.io/envoy-hot-restart-1d16b14555b5">类似的机制</a> 进行热重启，文件描述符通过Unix域套接字传递。</p>
<p>2018年底，Cloudflare 在<a href="https://blog.cloudflare.com/know-your-scm_rights/">博客</a> 中介绍了其使用的将文件描述符从nginx转移到Go TLS 1.3代理。</p>
<p>促使我写下这篇博文的关于Facebook如何实现零停机发布的论文，使用了与 <code>CMSG + SCM_RIGHTS</code> 相同的技巧，将活的文件描述符从将要结束的进程传递到新发布的进程。</p>
<h2 id="总结">总结</h2>
<p>如果使用得当，通过Unix域套接字传输文件描述符可以被证明是非常强大的。我希望这篇文章能让你对Unix域套接字和它的功能有一个更好的理解。</p>
<h2 id="references">References:</h2>
<ul>
<li><a href="https://www.man7.org/linux/man-pages/man7/unix.7.html">https://www.man7.org/linux/man-pages/man7/unix.7.html</a></li>
<li><a href="https://blog.cloudflare.com/know-your-scm_rights/">https://blog.cloudflare.com/know-your-scm_rights/</a></li>
<li>LWN.net has an interesting article on creating cycles when passing file descriptions over a Unix domain socket and implications for the fabulous new io_uring kernel API. <a href="https://lwn.net/Articles/779472/">https://lwn.net/Articles/779472/</a></li>
<li>The Linux Programming Interface <a href="https://learning.oreilly.com/library/view/the-linux-programming/9781593272203/">https://learning.oreilly.com/library/view/the-linux-programming/9781593272203/</a></li>
<li>UNIX Network Programming: The Sockets Networking API <a href="https://learning.oreilly.com/library/view/the-sockets-networking/0131411551/">https://learning.oreilly.com/library/view/the-sockets-networking/0131411551/</a></li>
</ul>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">bwangel</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2021-11-30
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content">本博客所有文章除特别声明外，均采用 <a href='http://creativecommons.org/licenses/by-nc-sa/3.0/cn/' rel='external nofollow' target='_blank'>CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处</span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%BF%BB%E8%AF%91/">翻译</a>
          <a href="/tags/linux/">linux</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/2021/12/17/introduction-to-apache-thrift/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Review 《Chapter 1. Introduction to Apache Thrift》</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/2021/01/16/review-memory-consistency-models/">
            <span class="next-text nav-default">Review 《Memory Consistency Models: A Tutorial》</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

  
  <script src="https://giscus.app/client.js"
        data-repo="anotherbwangel/blog-comment"
        data-repo-id="MDEwOlJlcG9zaXRvcnkxNDUyNzQwMDQ="
        data-category="Announcements"
        data-category-id="DIC_kwDOCKi0lM4CBFyL"
        data-mapping="pathname"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="bottom"
        data-theme="light"
        data-lang="zh-CN"
        crossorigin="anonymous"
        async>
  </script>
    <noscript>Please enable JavaScript to view the <a href="https://giscus.app/zh-CN">comments powered by giscus.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:bwangel.me@email.com" class="iconfont icon-email" title="email"></a>
      <a href="https://stackoverflow.com/users/5161084/bwangel" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="https://twitter.com/bwangel23" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://github.com/bwangelme" class="iconfont icon-github" title="github"></a>
      <a href="https://www.douban.com/people/bwangel/" class="iconfont icon-douban" title="douban"></a>
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2016 - 
    2022<span class="heart"><i class="iconfont icon-heart"></i></span><span><a href='https://bwangel.me/about'>bwangel</a></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        tags: 'ams',
        }
    };
  </script>
  <script type="text/javascript" async src="/lib/MathJax@3.2.0/es5/tex-mml-chtml.js"></script>

<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?f22fe9c7aece3dedec2af9976b092478";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>






</body>
</html>
